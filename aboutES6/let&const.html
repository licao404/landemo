<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>let&const</title>
</head>

<body>
    <script>

        //1*暂时性死区

        //在代码块内，使用let命令声明变量之前，该变量都是不可用的。
        //这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）
        // if (true) {
        // // TDZ开始
        // tmp = 'abc'; // Uncaught ReferenceError: tmp is not defined
        // console.log(tmp); // ReferenceError

        // let tmp; // TDZ结束
        // console.log(tmp); // undefined

        // tmp = 123;
        // console.log(tmp); // 123
        // }
        
        // “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
        //(块级作用域的写法代替立即执行匿名函数写法（IIFE）)
        // {
        //     typeof x; // ReferenceError
        //     let x;
        // }

        // ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，
        //防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，
        //现在有了这种规定，避免此类错误就很容易了。
        

        //暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，
        //只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

        //2*块级作用域{}
        //ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
        // 情况一
        if (true) {
            function f() {}
        }

        // 情况二
        try {
            function f() {}
        } catch(e) {
        }        
        //上面代码的两种函数声明，根据ES5的规定都是非法的。

        //但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错
        //ES5严格模式
        'use strict';
        if (true) {
            function f() {}
        }//报错

        //ES6严格模式
        'use strict';
        if (true) {
            function f() {}
        }//不报错

            
    </script>
</body>

</html>